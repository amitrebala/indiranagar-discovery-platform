# Story 4.4: Advanced Content Features and Memory Palace Enhancement

## Status
Draft

## Story
**As an** immersive content consumer,  
**I want** rich, multi-media content experiences that bring places to life through storytelling and visual elements,  
**so that** I can deeply understand and connect with places before visiting and feel confident in my exploration choices.

## Acceptance Criteria

1. Audio content integration allowing voice notes and ambient sound recordings from places
2. 360-degree photo capability for immersive place previews and spatial understanding
3. Interactive timeline features showing how places have evolved and changed over time
4. Story collections grouping related places into themed narratives (e.g., "Evolution of Indiranagar Cafes")
5. Seasonal photo comparisons showing places in different weather conditions and times of year
6. User-generated photo submissions with approval workflow for community content expansion
7. Advanced filtering for content types (photos, stories, audio, videos) with personalized content preferences

## Tasks / Subtasks

- [ ] Implement Audio Content System (AC: 1)
  - [ ] Build audio recording and playback infrastructure
  - [ ] Create voice note integration for place experiences
  - [ ] Add ambient sound recording and sharing capabilities
  - [ ] Implement audio transcription and accessibility features
  - [ ] Build audio content moderation and quality control

- [ ] Create 360-Degree Photo Integration (AC: 2)
  - [ ] Implement 360-degree photo upload and processing
  - [ ] Build immersive photo viewer with navigation controls
  - [ ] Add 360-degree photo integration with place detail pages
  - [ ] Create mobile-optimized 360-degree viewing experience
  - [ ] Implement 360-degree photo compression and optimization

- [ ] Build Interactive Timeline System (AC: 3)
  - [ ] Create place evolution timeline interface
  - [ ] Add historical photo and content organization by date
  - [ ] Implement timeline navigation and interaction controls
  - [ ] Build timeline content submission and management system
  - [ ] Create timeline analytics and engagement tracking

- [ ] Create Story Collections System (AC: 4)
  - [ ] Build themed story collection creation and management
  - [ ] Create collection navigation and discovery interface
  - [ ] Add collection sharing and social features
  - [ ] Implement collection analytics and performance tracking
  - [ ] Build collaborative collection creation tools

- [ ] Implement Seasonal Comparison System (AC: 5)
  - [ ] Create seasonal photo organization and comparison interface
  - [ ] Build weather-based photo categorization system
  - [ ] Add seasonal comparison widgets for place pages
  - [ ] Implement seasonal photo collection and curation
  - [ ] Create seasonal content recommendation engine

- [ ] Build Community Content Submission (AC: 6)
  - [ ] Create user-generated content submission interface
  - [ ] Implement content approval workflow and moderation
  - [ ] Add community contributor recognition and attribution
  - [ ] Build content quality scoring and filtering
  - [ ] Create community content analytics and engagement tracking

- [ ] Create Advanced Content Filtering (AC: 7)
  - [ ] Build comprehensive content type filtering system
  - [ ] Implement personalized content preference management
  - [ ] Add advanced search and discovery for multimedia content
  - [ ] Create content recommendation engine based on preferences
  - [ ] Build content consumption analytics and optimization

## Dev Notes

### Previous Story Insights
- **Story 2.2**: Memory palace foundation provides base for enhanced features
- **Story 3.1**: Community content submission patterns from suggestion system

### Enhanced Content Data Model
```typescript
interface MultimediaContent {
  id: string;
  place_id: string;
  type: ContentType;
  title: string;
  description: string;
  file_url: string;
  thumbnail_url?: string;
  metadata: ContentMetadata;
  creator: ContentCreator;
  status: ContentStatus;
  engagement_metrics: EngagementMetrics;
  created_at: string;
  updated_at: string;
}

type ContentType = 'photo' | 'audio' | 'video' | '360_photo' | 'story' | 'timeline_entry';

interface AudioContent extends MultimediaContent {
  duration_seconds: number;
  transcription?: string;
  ambient_sound_type?: 'conversation' | 'music' | 'nature' | 'traffic';
  recording_context: 'voice_note' | 'ambient_capture' | 'interview';
}

interface TimelineEntry {
  id: string;
  place_id: string;
  date: string;
  title: string;
  description: string;
  content_items: MultimediaContent[];
  historical_significance: string;
  sources: string[];
}

interface StoryCollection {
  id: string;
  title: string;
  description: string;
  theme: string;
  places: Place[];
  content_items: MultimediaContent[];
  curator_id: string;
  is_community_curated: boolean;
  view_count: number;
  like_count: number;
}
```

### File Locations
```
apps/web/
â”œâ”€â”€ components/content/
â”‚   â”œâ”€â”€ AudioPlayer.tsx              # Audio content playback
â”‚   â”œâ”€â”€ Audio360Viewer.tsx           # 360-degree photo viewer
â”‚   â”œâ”€â”€ InteractiveTimeline.tsx      # Place evolution timeline
â”‚   â”œâ”€â”€ StoryCollections.tsx         # Themed story navigation
â”‚   â”œâ”€â”€ SeasonalComparison.tsx       # Seasonal photo comparisons
â”‚   â”œâ”€â”€ CommunityContentSubmission.tsx # User content upload
â”‚   â””â”€â”€ AdvancedContentFilter.tsx    # Content type filtering
â”œâ”€â”€ lib/content/
â”‚   â”œâ”€â”€ audio-processing.ts          # Audio handling and transcription
â”‚   â”œâ”€â”€ 360-photo-processing.ts      # 360 photo optimization
â”‚   â”œâ”€â”€ timeline-management.ts       # Timeline data and navigation
â”‚   â”œâ”€â”€ story-collections.ts         # Collection creation and management
â”‚   â””â”€â”€ content-moderation.ts        # Community content approval
```

### Audio Content Integration
```typescript
const AudioContentPlayer = ({ audioContent }: { audioContent: AudioContent }) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const audioRef = useRef<HTMLAudioElement>(null);

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const handlePlayPause = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  return (
    <div className="audio-content-player bg-gray-50 rounded-lg p-4 mb-4">
      <div className="flex items-center space-x-4">
        <button
          onClick={handlePlayPause}
          className="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center text-white hover:bg-blue-600"
        >
          {isPlaying ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5 ml-1" />}
        </button>

        <div className="flex-1">
          <h4 className="font-medium text-sm mb-1">{audioContent.title}</h4>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <Volume2 className="w-4 h-4" />
            <span>{audioContent.recording_context}</span>
            <span>â€¢</span>
            <span>{formatTime(audioContent.duration_seconds)}</span>
          </div>
        </div>

        <div className="text-right">
          <div className="text-sm text-gray-500">
            {formatTime(currentTime)} / {formatTime(audioContent.duration_seconds)}
          </div>
        </div>
      </div>

      <audio
        ref={audioRef}
        src={audioContent.file_url}
        onTimeUpdate={(e) => setCurrentTime(e.currentTarget.currentTime)}
        onEnded={() => setIsPlaying(false)}
      />

      {audioContent.transcription && (
        <div className="mt-4 p-3 bg-white rounded border">
          <h5 className="font-medium text-xs text-gray-700 mb-2">Transcription</h5>
          <p className="text-sm text-gray-600">{audioContent.transcription}</p>
        </div>
      )}
    </div>
  );
};
```

### 360-Degree Photo Viewer
```typescript
const Photo360Viewer = ({ photo360 }: { photo360: MultimediaContent }) => {
  const viewerRef = useRef<HTMLDivElement>(null);
  const [viewer, setViewer] = useState<any>(null);

  useEffect(() => {
    if (viewerRef.current && !viewer) {
      // Initialize 360 photo viewer (using a library like Photo Sphere Viewer)
      const photoSphereViewer = new PhotoSphereViewer({
        container: viewerRef.current,
        panorama: photo360.file_url,
        navbar: [
          'autorotate',
          'zoom',
          'fullscreen'
        ],
        defaultZoomLvl: 30,
        touchmoveTwoFingers: true,
        mousewheelCtrlKey: false
      });

      setViewer(photoSphereViewer);
    }

    return () => {
      if (viewer) {
        viewer.destroy();
      }
    };
  }, [viewerRef, viewer, photo360.file_url]);

  return (
    <div className="photo-360-viewer mb-6">
      <div className="mb-3">
        <h3 className="font-medium text-lg">{photo360.title}</h3>
        <p className="text-sm text-gray-600">{photo360.description}</p>
      </div>

      <div 
        ref={viewerRef} 
        className="w-full h-96 rounded-lg overflow-hidden border"
        style={{ minHeight: '400px' }}
      />

      <div className="mt-3 flex items-center justify-between text-sm text-gray-500">
        <span>ðŸ“¸ 360Â° Interactive View</span>
        <span>Drag to look around â€¢ Scroll to zoom</span>
      </div>
    </div>
  );
};
```

### Interactive Timeline Implementation
```typescript
const InteractiveTimeline = ({ place }: { place: Place }) => {
  const [timelineEntries, setTimelineEntries] = useState<TimelineEntry[]>([]);
  const [selectedEntry, setSelectedEntry] = useState<TimelineEntry | null>(null);

  useEffect(() => {
    loadTimelineEntries(place.id);
  }, [place.id]);

  const loadTimelineEntries = async (placeId: string) => {
    const entries = await getPlaceTimeline(placeId);
    setTimelineEntries(entries.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()));
  };

  return (
    <div className="interactive-timeline mb-8">
      <h3 className="text-xl font-semibold mb-6">Evolution of {place.name}</h3>

      <div className="timeline-container relative">
        <div className="timeline-line absolute left-8 top-0 bottom-0 w-0.5 bg-gray-300" />

        {timelineEntries.map((entry, index) => (
          <div key={entry.id} className="timeline-entry relative mb-8">
            <div className="timeline-marker absolute left-6 w-4 h-4 bg-blue-500 rounded-full border-4 border-white shadow" />
            
            <div className="timeline-content ml-16 bg-white rounded-lg border shadow-sm p-4">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium text-blue-600">
                  {new Date(entry.date).getFullYear()}
                </span>
                <button
                  onClick={() => setSelectedEntry(entry)}
                  className="text-sm text-gray-500 hover:text-gray-700"
                >
                  View Details â†’
                </button>
              </div>
              
              <h4 className="font-medium mb-2">{entry.title}</h4>
              <p className="text-sm text-gray-600 mb-3">{entry.description}</p>
              
              {entry.content_items.length > 0 && (
                <div className="flex space-x-2 overflow-x-auto">
                  {entry.content_items.slice(0, 3).map(item => (
                    <img
                      key={item.id}
                      src={item.thumbnail_url || item.file_url}
                      alt={item.title}
                      className="w-16 h-16 object-cover rounded flex-shrink-0"
                    />
                  ))}
                  {entry.content_items.length > 3 && (
                    <div className="w-16 h-16 bg-gray-100 rounded flex items-center justify-center text-xs text-gray-500">
                      +{entry.content_items.length - 3}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        ))}
      </div>

      {selectedEntry && (
        <TimelineEntryModal
          entry={selectedEntry}
          onClose={() => setSelectedEntry(null)}
        />
      )}
    </div>
  );
};
```

### Story Collections System
```typescript
const StoryCollections = ({ place }: { place: Place }) => {
  const [collections, setCollections] = useState<StoryCollection[]>([]);
  const [selectedCollection, setSelectedCollection] = useState<StoryCollection | null>(null);

  useEffect(() => {
    loadRelevantCollections(place.id);
  }, [place.id]);

  const loadRelevantCollections = async (placeId: string) => {
    const relatedCollections = await getCollectionsForPlace(placeId);
    setCollections(relatedCollections);
  };

  return (
    <div className="story-collections mb-8">
      <h3 className="text-xl font-semibold mb-4">Featured in Collections</h3>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {collections.map(collection => (
          <div
            key={collection.id}
            className="collection-card bg-white rounded-lg border shadow-sm overflow-hidden cursor-pointer hover:shadow-md transition-shadow"
            onClick={() => setSelectedCollection(collection)}
          >
            <div className="aspect-video bg-gradient-to-r from-blue-400 to-purple-500 relative">
              {collection.content_items[0] && (
                <img
                  src={collection.content_items[0].thumbnail_url}
                  alt={collection.title}
                  className="w-full h-full object-cover"
                />
              )}
              <div className="absolute inset-0 bg-black bg-opacity-40 flex items-end">
                <div className="p-4 text-white">
                  <h4 className="font-semibold">{collection.title}</h4>
                  <p className="text-sm opacity-90">{collection.places.length} places</p>
                </div>
              </div>
            </div>

            <div className="p-4">
              <p className="text-sm text-gray-600 mb-3">{collection.description}</p>
              <div className="flex items-center justify-between text-xs text-gray-500">
                <span>{collection.view_count} views</span>
                <span>{collection.like_count} likes</span>
              </div>
            </div>
          </div>
        ))}
      </div>

      {selectedCollection && (
        <CollectionModal
          collection={selectedCollection}
          onClose={() => setSelectedCollection(null)}
        />
      )}
    </div>
  );
};
```

### Key Features
- **Rich Multimedia**: Audio, 360Â° photos, and interactive content
- **Historical Context**: Timeline showing place evolution over time
- **Curated Narratives**: Story collections connecting related places
- **Seasonal Intelligence**: Photo comparisons across different seasons
- **Community Contributions**: User-generated content with approval workflow
- **Personalized Experience**: Content filtering based on user preferences

## Testing

### Key Test Scenarios
- Audio content upload, playback, and transcription accuracy
- 360-degree photo upload, processing, and viewer functionality
- Timeline creation, navigation, and historical content organization
- Story collection creation, management, and discovery
- Seasonal photo comparison accuracy and display
- Community content submission and approval workflow
- Advanced content filtering and personalization features

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| [Current Date] | 1.0 | Initial story creation with advanced multimedia content and memory palace enhancement | Scrum Master |

## Dev Agent Record

This section is populated by the development agent during implementation.

## QA Results

Results from QA Agent QA review of the completed story implementation.