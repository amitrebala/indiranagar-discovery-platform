# Story 2.5: Mobile-Optimized Exploration Experience

## Status
Draft

## Story
**As an** on-the-go explorer,  
**I want** seamless mobile experience optimized for discovering places while walking around Indiranagar,  
**so that** I can use the platform effectively during actual exploration and share discoveries immediately.

## Acceptance Criteria

1. Location-aware suggestions triggered when GPS detects proximity to recommended places
2. Quick share functionality with pre-formatted social media templates for immediate sharing
3. Offline content caching for core place information and maps in areas with poor connectivity
4. Voice navigation integration for hands-free journey guidance during walks
5. One-handed mobile navigation optimized for walking use with large touch targets
6. Battery-efficient location tracking that doesn't drain device during extended exploration
7. Camera integration allowing quick photo capture with automatic place association for future content updates

## Tasks / Subtasks

- [ ] Implement Location-Aware Proximity Suggestions (AC: 1)
  - [ ] Create background geolocation tracking with proximity detection
  - [ ] Build proximity notification system for nearby recommended places
  - [ ] Implement geofence triggers for contextual place suggestions
  - [ ] Add smart notification timing to avoid notification fatigue
  - [ ] Create proximity suggestion UI with actionable recommendations

- [ ] Build Quick Share Social Media Integration (AC: 2)
  - [ ] Create pre-formatted sharing templates for different social platforms
  - [ ] Implement native sharing API with fallback options
  - [ ] Add quick photo + place combination sharing
  - [ ] Create customizable share messages with place details
  - [ ] Build sharing analytics and engagement tracking

- [ ] Implement Offline Content Caching (AC: 3)
  - [ ] Create place data caching strategy for offline access
  - [ ] Implement map tile caching for Indiranagar area
  - [ ] Build offline journey data synchronization
  - [ ] Add offline indicator and cached content management
  - [ ] Create background sync when connectivity returns

- [ ] Add Voice Navigation and Guidance (AC: 4)
  - [ ] Integrate speech synthesis for turn-by-turn directions
  - [ ] Create voice-activated journey progression
  - [ ] Implement hands-free place information narration
  - [ ] Add voice search capabilities for place discovery
  - [ ] Build voice accessibility features for visually impaired users

- [ ] Optimize One-Handed Mobile Navigation (AC: 5)
  - [ ] Design thumb-friendly interface layout for single-hand use
  - [ ] Implement large touch targets (minimum 44px) throughout interface
  - [ ] Create swipe gestures for common actions during walking
  - [ ] Add bottom navigation for easy thumb access
  - [ ] Optimize interface for various phone sizes and grip styles

- [ ] Create Battery-Efficient Location Tracking (AC: 6)
  - [ ] Implement intelligent location sampling to preserve battery
  - [ ] Create power management strategies for extended exploration
  - [ ] Add location accuracy optimization based on movement patterns
  - [ ] Build battery usage monitoring and user notifications
  - [ ] Implement location caching to reduce GPS frequency

- [ ] Build Camera Integration and Content Association (AC: 7)
  - [ ] Create quick camera access from any screen during exploration
  - [ ] Implement automatic place detection for captured photos
  - [ ] Build photo geotagging with place association
  - [ ] Add photo upload queue for later content management
  - [ ] Create photo contribution workflow for community content

## Dev Notes

### Previous Story Insights
- **Story 2.1**: Enhanced map provides foundation for mobile location-aware features
- **Story 2.3**: Journey system provides context for voice navigation and walking guidance
- **Story 2.4**: Search system provides foundation for voice search capabilities
- **Story 1.6**: Community features can integrate with photo contribution system

### Mobile-Optimized Architecture
```typescript
interface MobileExplorationContext {
  current_location: Coordinates;
  movement_state: 'stationary' | 'walking' | 'transit';
  battery_level: number;
  network_status: 'online' | 'offline' | 'limited';
  proximity_places: ProximityPlace[];
  active_journey?: JourneyExperience;
  voice_navigation_active: boolean;
}

interface ProximityPlace {
  place: Place;
  distance_meters: number;
  notification_sent: boolean;
  suggested_actions: ProximityAction[];
}

interface ProximityAction {
  type: 'visit_now' | 'add_to_journey' | 'learn_more' | 'share_location';
  label: string;
  priority: 'high' | 'medium' | 'low';
}
```

### File Locations for Mobile Features
```
apps/web/
├── components/mobile/
│   ├── ProximityNotifications.tsx   # Location-aware suggestions
│   ├── QuickSharePanel.tsx         # Social media sharing
│   ├── OfflineIndicator.tsx        # Offline status and cached content
│   ├── VoiceNavigation.tsx         # Voice guidance system
│   ├── OneHandedNavigation.tsx     # Thumb-friendly navigation
│   ├── BatteryOptimizer.tsx       # Battery management
│   └── CameraIntegration.tsx      # Photo capture and association
├── lib/mobile/
│   ├── proximity-detection.ts      # Geofence and proximity logic
│   ├── offline-cache.ts           # Offline content management
│   ├── voice-synthesis.ts         # Text-to-speech integration
│   ├── battery-optimization.ts    # Power management
│   └── photo-association.ts       # Camera and place linking
├── hooks/
│   ├── useProximityDetection.ts   # Proximity tracking hook
│   ├── useOfflineCache.ts         # Offline content hook  
│   ├── useVoiceNavigation.ts      # Voice guidance hook
│   └── useBatteryOptimization.ts  # Battery management hook
```

### Proximity Detection Implementation
```typescript
const useProximityDetection = () => {
  const [proximityPlaces, setProximityPlaces] = useState<ProximityPlace[]>([]);
  const [lastNotificationTime, setLastNotificationTime] = useState<Date>();

  useEffect(() => {
    let watchId: number;
    
    const startProximityTracking = () => {
      if ('geolocation' in navigator) {
        watchId = navigator.geolocation.watchPosition(
          (position) => {
            checkProximityToPlaces(position.coords);
          },
          (error) => console.warn('Geolocation error:', error),
          {
            enableHighAccuracy: false, // Battery optimization
            timeout: 10000,
            maximumAge: 30000 // Use cached location for 30 seconds
          }
        );
      }
    };

    startProximityTracking();
    return () => {
      if (watchId) navigator.geolocation.clearWatch(watchId);
    };
  }, []);

  const checkProximityToPlaces = async (coords: GeolocationCoordinates) => {
    const nearbyPlaces = await getNearbyPlaces(coords, 100); // 100m radius
    
    const proximityPlaces = nearbyPlaces.map(place => ({
      place,
      distance_meters: calculateDistance(coords, place),
      notification_sent: false,
      suggested_actions: generateProximityActions(place, coords)
    }));

    // Smart notification timing - avoid spam
    const shouldNotify = !lastNotificationTime || 
      (Date.now() - lastNotificationTime.getTime()) > 300000; // 5 minutes

    if (shouldNotify && proximityPlaces.length > 0) {
      triggerProximityNotification(proximityPlaces[0]);
      setLastNotificationTime(new Date());
    }

    setProximityPlaces(proximityPlaces);
  };

  const triggerProximityNotification = (proximityPlace: ProximityPlace) => {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(`You're near ${proximityPlace.place.name}`, {
        body: `${proximityPlace.distance_meters}m away • ${proximityPlace.place.rating}★`,
        icon: proximityPlace.place.primary_image,
        tag: proximityPlace.place.id,
        actions: [
          { action: 'view', title: 'View Details' },
          { action: 'navigate', title: 'Get Directions' }
        ]
      });
    }
  };

  return { proximityPlaces, requestNotificationPermission };
};
```

### Quick Share Implementation
```typescript
const QuickSharePanel = ({ place, photo }: QuickShareProps) => {
  const [isSharing, setIsSharing] = useState(false);
  
  const shareTemplates = {
    instagram: {
      text: `Discovered ${place.name} in Indiranagar! ${place.rating}★ #IndiNagar #LocalGems`,
      hashtags: ['IndiNagar', 'LocalGems', 'BangaloreEats']
    },
    whatsapp: {
      text: `Hey! Just found this amazing place: ${place.name} in Indiranagar. ${place.description.substring(0, 100)}... Worth checking out! 📍 Location: ${window.location.origin}/places/${place.slug}`
    },
    twitter: {
      text: `Just discovered ${place.name} in #Indiranagar - ${place.rating}★ gem! ${place.description.substring(0, 80)}... #LocalFinds #Bangalore`,
      url: `${window.location.origin}/places/${place.slug}`
    }
  };

  const handleNativeShare = async () => {
    if (navigator.share) {
      try {
        setIsSharing(true);
        await navigator.share({
          title: place.name,
          text: `Check out ${place.name} in Indiranagar!`,
          url: `${window.location.origin}/places/${place.slug}`,
          files: photo ? [photo] : undefined
        });
      } catch (error) {
        console.log('Share cancelled');
      } finally {
        setIsSharing(false);
      }
    } else {
      // Fallback to custom share modal
      showCustomShareModal();
    }
  };

  const shareToWhatsApp = () => {
    const template = shareTemplates.whatsapp;
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(template.text)}`;
    window.open(whatsappUrl, '_blank');
  };

  const shareToInstagram = () => {
    // Instagram sharing requires app integration or manual copy
    navigator.clipboard.writeText(shareTemplates.instagram.text);
    // Open Instagram app if available
    window.open('instagram://camera', '_blank');
  };

  return (
    <div className="quick-share-panel bg-white rounded-t-xl shadow-lg p-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="font-semibold text-lg">Share {place.name}</h3>
        <button onClick={() => setIsSharing(false)}>
          <X className="w-5 h-5" />
        </button>
      </div>

      {photo && (
        <div className="mb-4">
          <img src={photo} alt="Captured photo" className="w-full h-32 object-cover rounded-lg" />
        </div>
      )}

      <div className="grid grid-cols-2 gap-3">
        <button
          onClick={handleNativeShare}
          className="flex items-center justify-center p-3 bg-blue-100 rounded-lg"
          disabled={isSharing}
        >
          <Share className="w-5 h-5 mr-2" />
          Quick Share
        </button>
        
        <button
          onClick={shareToWhatsApp}
          className="flex items-center justify-center p-3 bg-green-100 rounded-lg"
        >
          <MessageCircle className="w-5 h-5 mr-2" />
          WhatsApp
        </button>
        
        <button
          onClick={shareToInstagram}
          className="flex items-center justify-center p-3 bg-pink-100 rounded-lg"
        >
          <Camera className="w-5 h-5 mr-2" />
          Instagram
        </button>
        
        <button
          onClick={() => copyPlaceLink(place)}
          className="flex items-center justify-center p-3 bg-gray-100 rounded-lg"
        >
          <Link className="w-5 h-5 mr-2" />
          Copy Link
        </button>
      </div>
    </div>
  );
};
```

### Offline Content Caching
```typescript
const useOfflineCache = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [cachedPlaces, setCachedPlaces] = useState<Place[]>([]);
  const [cachedJourneys, setCachedJourneys] = useState<JourneyExperience[]>([]);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const cacheEssentialContent = useCallback(async () => {
    try {
      // Cache nearby places
      if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(async (position) => {
          const nearbyPlaces = await getNearbyPlaces(position.coords, 5000); // 5km radius
          await storeInCache('nearby-places', nearbyPlaces);
          setCachedPlaces(nearbyPlaces);
        });
      }

      // Cache popular journeys
      const popularJourneys = await getPopularJourneys();
      await storeInCache('popular-journeys', popularJourneys);
      setCachedJourneys(popularJourneys);

      // Cache map tiles for Indiranagar area
      await cacheMapTiles({
        north: 13.0000,
        south: 12.9500,
        east: 77.6500,
        west: 77.5800
      });

    } catch (error) {
      console.warn('Failed to cache content:', error);
    }
  }, []);

  const getCachedContent = async (key: string) => {
    try {
      const cached = await getFromCache(key);
      return cached || null;
    } catch (error) {
      console.warn('Failed to retrieve cached content:', error);
      return null;
    }
  };

  const syncWhenOnline = useCallback(async () => {
    if (isOnline) {
      // Sync any offline changes
      const offlineChanges = await getFromCache('offline-changes');
      if (offlineChanges && offlineChanges.length > 0) {
        await syncOfflineChanges(offlineChanges);
        await removeFromCache('offline-changes');
      }
    }
  }, [isOnline]);

  useEffect(() => {
    syncWhenOnline();
  }, [isOnline, syncWhenOnline]);

  return {
    isOnline,
    cachedPlaces,
    cachedJourneys,
    cacheEssentialContent,
    getCachedContent
  };
};
```

### Voice Navigation Integration
```typescript
const VoiceNavigation = ({ journey, currentStop }: VoiceNavigationProps) => {
  const [isVoiceActive, setIsVoiceActive] = useState(false);
  const [speechSynthesis, setSpeechSynthesis] = useState<SpeechSynthesis | null>(null);

  useEffect(() => {
    if ('speechSynthesis' in window) {
      setSpeechSynthesis(window.speechSynthesis);
    }
  }, []);

  const speakDirections = (text: string) => {
    if (speechSynthesis && isVoiceActive) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.8;
      utterance.pitch = 1;
      utterance.volume = 0.8;
      speechSynthesis.speak(utterance);
    }
  };

  const generateNavigationText = (currentStop: JourneyStop, nextStop?: JourneyStop) => {
    let text = `You've arrived at ${currentStop.place.name}. `;
    
    if (currentStop.activities.length > 0) {
      text += `Suggested activities: ${currentStop.activities.map(a => a.name).join(', ')}. `;
    }
    
    if (nextStop) {
      text += `When ready, your next stop is ${nextStop.place.name}, approximately ${currentStop.walking_directions.estimated_minutes} minutes walk.`;
    } else {
      text += 'This is your final destination. Enjoy exploring!';
    }
    
    return text;
  };

  const handleVoiceCommand = (command: string) => {
    const lowercaseCommand = command.toLowerCase();
    
    if (lowercaseCommand.includes('next stop')) {
      const nextStopIndex = currentStop + 1;
      if (nextStopIndex < journey.journey_stops.length) {
        const nextStop = journey.journey_stops[nextStopIndex];
        speakDirections(`Next stop: ${nextStop.place.name}. ${nextStop.walking_directions.description}`);
      }
    } else if (lowercaseCommand.includes('current location')) {
      const currentPlace = journey.journey_stops[currentStop].place;
      speakDirections(`You are at ${currentPlace.name}. ${currentPlace.description}`);
    } else if (lowercaseCommand.includes('time remaining')) {
      const remainingTime = calculateRemainingJourneyTime(journey, currentStop);
      speakDirections(`Estimated time remaining: ${remainingTime} minutes.`);
    }
  };

  return (
    <div className="voice-navigation fixed bottom-20 right-4 z-50">
      <button
        onClick={() => setIsVoiceActive(!isVoiceActive)}
        className={`w-14 h-14 rounded-full shadow-lg flex items-center justify-center ${
          isVoiceActive ? 'bg-green-500 text-white' : 'bg-white text-gray-700'
        }`}
      >
        {isVoiceActive ? <Volume2 className="w-6 h-6" /> : <VolumeX className="w-6 h-6" />}
      </button>
      
      {isVoiceActive && (
        <div className="absolute bottom-16 right-0 bg-white rounded-lg shadow-lg p-3 min-w-48">
          <p className="text-sm text-gray-600 mb-2">Voice guidance active</p>
          <div className="text-xs text-gray-500">
            Try: "Next stop", "Current location", "Time remaining"
          </div>
        </div>
      )}
    </div>
  );
};
```

### One-Handed Navigation Optimization
```typescript
const OneHandedNavigation = ({ children }: { children: React.ReactNode }) => {
  const [isLeftHanded, setIsLeftHanded] = useState(false);

  const navigationStyle = {
    position: 'fixed' as const,
    bottom: 0,
    [isLeftHanded ? 'left' : 'right']: 0,
    width: '100%',
    maxWidth: '400px',
    zIndex: 1000
  };

  return (
    <div className="one-handed-container">
      {/* Main content area optimized for thumb reach */}
      <div className="pb-20"> {/* Space for bottom navigation */}
        {children}
      </div>

      {/* Bottom navigation optimized for thumb access */}
      <nav style={navigationStyle} className="bg-white border-t border-gray-200 px-4 py-2">
        <div className="flex justify-around items-center">
          <NavButton icon={<Home />} label="Home" />
          <NavButton icon={<Search />} label="Search" />
          <NavButton icon={<Map />} label="Map" />
          <NavButton icon={<Camera />} label="Capture" primary />
          <NavButton icon={<User />} label="Profile" />
        </div>
      </nav>

      {/* Hand preference toggle */}
      <button
        onClick={() => setIsLeftHanded(!isLeftHanded)}
        className="fixed top-4 right-4 p-2 bg-gray-100 rounded-full z-50"
        aria-label="Switch hand preference"
      >
        <Hand className="w-4 h-4" />
      </button>
    </div>
  );
};

const NavButton = ({ icon, label, primary = false }: NavButtonProps) => (
  <button
    className={`flex flex-col items-center py-2 px-3 min-h-12 min-w-12 ${
      primary ? 'bg-yellow-400 rounded-full' : ''
    }`}
  >
    {icon}
    <span className="text-xs mt-1">{label}</span>
  </button>
);
```

### Battery Optimization Strategy
```typescript
const useBatteryOptimization = () => {
  const [batteryLevel, setBatteryLevel] = useState<number>(1);
  const [isLowPower, setIsLowPower] = useState(false);

  useEffect(() => {
    const getBatteryInfo = async () => {
      if ('getBattery' in navigator) {
        const battery = await (navigator as any).getBattery();
        setBatteryLevel(battery.level);
        setIsLowPower(battery.level < 0.2);

        battery.addEventListener('levelchange', () => {
          setBatteryLevel(battery.level);
          setIsLowPower(battery.level < 0.2);
        });
      }
    };

    getBatteryInfo();
  }, []);

  const optimizeForBattery = useCallback(() => {
    if (isLowPower) {
      return {
        locationUpdateInterval: 60000, // 1 minute instead of 30 seconds
        enableHighAccuracy: false,
        maximumAge: 300000, // 5 minutes cache
        disableAnimations: true,
        reduceImageQuality: true,
        disableBackgroundSync: true
      };
    }
    
    return {
      locationUpdateInterval: 30000,
      enableHighAccuracy: true,
      maximumAge: 60000,
      disableAnimations: false,
      reduceImageQuality: false,
      disableBackgroundSync: false
    };
  }, [isLowPower]);

  return {
    batteryLevel,
    isLowPower,
    optimizationSettings: optimizeForBattery()
  };
};
```

### Camera Integration and Photo Association
```typescript
const CameraIntegration = () => {
  const [isCameraOpen, setIsCameraOpen] = useState(false);
  const [capturedPhoto, setCapturedPhoto] = useState<string | null>(null);
  const [nearbyPlace, setNearbyPlace] = useState<Place | null>(null);

  const capturePhoto = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' } 
      });
      
      // Implementation would use camera API or file input
      const photo = await takePicture(stream);
      setCapturedPhoto(photo);
      
      // Automatically detect nearby place
      if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(async (position) => {
          const nearby = await findNearestPlace(position.coords, 50); // 50m radius
          setNearbyPlace(nearby);
        });
      }
    } catch (error) {
      console.error('Camera access denied:', error);
    }
  };

  const associatePhotoWithPlace = async (photo: string, place: Place) => {
    const photoData = {
      image_data: photo,
      place_id: place.id,
      captured_at: new Date().toISOString(),
      contributor_type: 'community',
      pending_review: true
    };

    // Queue for upload when online
    await queuePhotoUpload(photoData);
  };

  return (
    <div className="camera-integration">
      <button
        onClick={() => setIsCameraOpen(true)}
        className="fixed bottom-24 right-4 w-14 h-14 bg-yellow-400 rounded-full shadow-lg flex items-center justify-center z-50"
      >
        <Camera className="w-6 h-6" />
      </button>

      {isCameraOpen && (
        <div className="fixed inset-0 bg-black z-50">
          <CameraInterface 
            onCapture={capturePhoto}
            onClose={() => setIsCameraOpen(false)}
          />
        </div>
      )}

      {capturedPhoto && nearbyPlace && (
        <PhotoAssociationModal
          photo={capturedPhoto}
          suggestedPlace={nearbyPlace}
          onAssociate={(place) => associatePhotoWithPlace(capturedPhoto, place)}
          onDiscard={() => setCapturedPhoto(null)}
        />
      )}
    </div>
  );
};
```

### Performance Considerations
- **GPS Optimization**: Intelligent sampling based on movement patterns
- **Image Compression**: Automatic photo compression for uploads
- **Background Sync**: Queue offline actions for later synchronization
- **Memory Management**: Efficient cleanup of camera resources
- **Network Optimization**: Prioritize essential content for offline caching

### Integration Dependencies
- **Story 2.1**: Enhanced map for location-based features
- **Story 2.3**: Journey system for voice navigation
- **Story 2.4**: Search system for voice search capabilities
- **Story 1.6**: Community features for photo contributions

### Privacy and Permissions
- **Location Access**: Clear explanation of location usage
- **Camera Permissions**: Transparent camera access requests
- **Notification Permissions**: Optional proximity notifications
- **Data Usage**: Clear indication of offline vs online modes

### Accessibility Features [Source: architecture/coding-standards.md]
- **Voice Navigation**: Full voice guidance for visually impaired users
- **Large Touch Targets**: All interactive elements minimum 44px
- **High Contrast**: Interface works in high contrast mode
- **Screen Reader Support**: Full compatibility with screen readers
- **Motor Accessibility**: One-handed operation accommodates limited mobility

## Testing

### Testing Framework [Source: architecture/testing-infrastructure.md]
- **Component Tests**: Mobile-specific components and hooks
- **E2E Tests**: Mobile user journeys with device simulation
- **Performance Tests**: Battery usage and location tracking efficiency
- **Device Tests**: Cross-device testing on various mobile devices

### Test File Locations
- **Component Tests**: `apps/web/tests/components/mobile/`
  - `ProximityNotifications.test.tsx`
  - `QuickSharePanel.test.tsx`
  - `VoiceNavigation.test.tsx`
  - `CameraIntegration.test.tsx`
- **Mobile E2E Tests**: `apps/web/tests/e2e/mobile-exploration.spec.ts`
- **Performance Tests**: `apps/web/tests/performance/mobile-optimization.test.ts`

### Key Test Scenarios
- **Proximity Detection**: Test geolocation and notification triggers
- **Offline Functionality**: Test content caching and offline access
- **Voice Navigation**: Test speech synthesis and voice commands
- **Camera Integration**: Test photo capture and place association
- **Battery Optimization**: Test power-efficient location tracking
- **One-Handed Use**: Test thumb-friendly navigation
- **Share Functionality**: Test social media sharing workflows
- **Performance**: Test mobile app performance and responsiveness

### Testing Standards [Source: architecture/testing-infrastructure.md]
- Mock geolocation API for consistent location testing
- Test offline scenarios with network simulation
- Include accessibility testing with mobile screen readers
- Test battery optimization with simulated battery levels
- Verify touch target sizes meet mobile accessibility guidelines

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| [Current Date] | 1.0 | Initial story creation with comprehensive mobile-optimized exploration features | Scrum Master |

## Dev Agent Record

This section is populated by the development agent during implementation.

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be filled by Dev Agent]

### Completion Notes List
[To be filled by Dev Agent]

### File List
[To be filled by Dev Agent]

## QA Results

Results from QA Agent QA review of the completed story implementation.