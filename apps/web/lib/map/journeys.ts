import { LatLng } from 'leaflet'
import type { Place } from '@/lib/validations'
import type { JourneyRoute, PlaceConnection } from '@/components/map/JourneyRouteVisualization'

// Journey difficulty levels\nexport type DifficultyLevel = 'easy' | 'moderate' | 'challenging'\n\n// Journey themes for different weather/mood contexts\nexport type JourneyTheme = \n  | 'morning-coffee'\n  | 'rainy-day'\n  | 'sunny-exploration'\n  | 'evening-food'\n  | 'cultural-walk'\n  | 'shopping-spree'\n  | 'romantic-date'\n\n// Journey creation utilities\nexport function createJourneyRoute(\n  id: string,\n  name: string,\n  places: Place[],\n  options: {\n    description?: string\n    difficulty?: DifficultyLevel\n    weatherDependent?: boolean\n    theme?: JourneyTheme\n    color?: string\n  } = {}\n): JourneyRoute {\n  const connections = createPlaceConnections(places)\n  const estimatedDuration = calculateJourneyDuration(connections)\n  \n  return {\n    id,\n    name,\n    description: options.description || `A journey through ${places.length} amazing places`,\n    places: connections,\n    estimated_duration: estimatedDuration,\n    difficulty_level: options.difficulty || 'easy',\n    weather_dependency: options.weatherDependent || false,\n    color: options.color || getThemeColor(options.theme)\n  }\n}\n\n// Create place connections with walking routes\nfunction createPlaceConnections(places: Place[]): PlaceConnection[] {\n  return places.map((place, index) => ({\n    place_id: place.id,\n    place,\n    order: index,\n    walking_time_minutes: index < places.length - 1 \n      ? calculateWalkingTime(place, places[index + 1])\n      : 0,\n    path_coordinates: index < places.length - 1\n      ? generateWalkingPath(place, places[index + 1])\n      : [],\n    notes: generateConnectionNotes(place, places[index + 1])\n  }))\n}\n\n// Calculate walking time between two places\nfunction calculateWalkingTime(from: Place, to: Place): number {\n  if (!to) return 0\n  \n  const distance = getDistanceFromLatLonInKm(\n    from.latitude, from.longitude,\n    to.latitude, to.longitude\n  )\n  \n  // Average walking speed: 5 km/h\n  const walkingTimeHours = distance / 5\n  const walkingTimeMinutes = Math.round(walkingTimeHours * 60)\n  \n  // Add 2-5 minutes for navigation and street crossing\n  const navigationBuffer = Math.max(2, Math.min(5, walkingTimeMinutes * 0.2))\n  \n  return Math.round(walkingTimeMinutes + navigationBuffer)\n}\n\n// Generate walking path between two places\nfunction generateWalkingPath(from: Place, to: Place): LatLng[] {\n  if (!to) return []\n  \n  const fromLatLng = new LatLng(from.latitude, from.longitude)\n  const toLatLng = new LatLng(to.latitude, to.longitude)\n  \n  // For now, create a simple direct path\n  // In a real implementation, this could use routing APIs like OpenRouteService\n  const path = [fromLatLng, toLatLng]\n  \n  // Add intermediate points for longer distances to create more natural curves\n  const distance = getDistanceFromLatLonInKm(\n    from.latitude, from.longitude,\n    to.latitude, to.longitude\n  )\n  \n  if (distance > 0.5) { // More than 500m\n    const midLat = (from.latitude + to.latitude) / 2\n    const midLng = (from.longitude + to.longitude) / 2\n    \n    // Add slight curve to make path more natural\n    const offset = 0.0005 // Small offset for curve\n    const midPoint = new LatLng(midLat + offset, midLng + offset)\n    \n    path.splice(1, 0, midPoint)\n  }\n  \n  return path\n}\n\n// Generate connection notes between places\nfunction generateConnectionNotes(from: Place, to?: Place): string | undefined {\n  if (!to) return undefined\n  \n  const distance = getDistanceFromLatLonInKm(\n    from.latitude, from.longitude,\n    to.latitude, to.longitude\n  )\n  \n  if (distance < 0.2) {\n    return \"Very close - easy walk\"\n  } else if (distance < 0.5) {\n    return \"Short pleasant walk\"\n  } else if (distance < 1.0) {\n    return \"Moderate walk through the neighborhood\"\n  } else {\n    return \"Longer walk - consider the weather\"\n  }\n}\n\n// Calculate total journey duration including stops\nfunction calculateJourneyDuration(connections: PlaceConnection[]): number {\n  const walkingTime = connections.reduce((total, conn) => \n    total + conn.walking_time_minutes, 0\n  )\n  \n  // Estimate 15-30 minutes per stop depending on place type\n  const stopTime = connections.length * 20 // Average 20 minutes per stop\n  \n  return walkingTime + stopTime\n}\n\n// Get theme-based color\nfunction getThemeColor(theme?: JourneyTheme): string {\n  const themeColors: Record<JourneyTheme, string> = {\n    'morning-coffee': '#8B4513', // Brown\n    'rainy-day': '#4682B4', // Steel blue\n    'sunny-exploration': '#FFD700', // Gold\n    'evening-food': '#DC143C', // Crimson\n    'cultural-walk': '#9370DB', // Medium purple\n    'shopping-spree': '#FF69B4', // Hot pink\n    'romantic-date': '#FF1493' // Deep pink\n  }\n  \n  return theme ? themeColors[theme] : '#2D5016' // Default green\n}\n\n// Distance calculation utility\nfunction getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371 // Radius of the earth in km\n  const dLat = deg2rad(lat2 - lat1)\n  const dLon = deg2rad(lon2 - lon1)\n  const a = \n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon / 2) * Math.sin(dLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n  const d = R * c // Distance in km\n  return d\n}\n\nfunction deg2rad(deg: number): number {\n  return deg * (Math.PI / 180)\n}\n\n// Predefined journey templates\nexport const SAMPLE_JOURNEYS: Partial<JourneyRoute>[] = [\n  {\n    id: 'morning-coffee-crawl',\n    name: 'Morning Coffee Crawl',\n    description: 'Start your day with the best coffee spots in Indiranagar',\n    difficulty_level: 'easy',\n    weather_dependency: false,\n    color: '#8B4513'\n  },\n  {\n    id: 'rainy-day-indoor',\n    name: 'Rainy Day Refuge',\n    description: 'Perfect spots to wait out the rain with good food and atmosphere',\n    difficulty_level: 'easy',\n    weather_dependency: true,\n    color: '#4682B4'\n  },\n  {\n    id: 'sunset-food-walk',\n    name: 'Sunset Food Walk',\n    description: 'Evening exploration of Indiranagar\\'s culinary delights',\n    difficulty_level: 'moderate',\n    weather_dependency: false,\n    color: '#DC143C'\n  }\n]\n\n// Journey filtering and search\nexport function filterJourneysByWeather(\n  journeys: JourneyRoute[],\n  weatherCondition: string\n): JourneyRoute[] {\n  return journeys.filter(journey => {\n    if (weatherCondition === 'rainy') {\n      // Prefer indoor or covered routes for rain\n      return journey.weather_dependency || journey.name.toLowerCase().includes('indoor')\n    }\n    \n    if (weatherCondition === 'sunny') {\n      // Any journey is good for sunny weather, prefer outdoor ones\n      return !journey.weather_dependency || journey.name.toLowerCase().includes('walk')\n    }\n    \n    return true // Default: show all journeys\n  })\n}\n\nexport function filterJourneysByDifficulty(\n  journeys: JourneyRoute[],\n  maxDifficulty: DifficultyLevel\n): JourneyRoute[] {\n  const difficultyOrder = ['easy', 'moderate', 'challenging']\n  const maxIndex = difficultyOrder.indexOf(maxDifficulty)\n  \n  return journeys.filter(journey => {\n    const journeyIndex = difficultyOrder.indexOf(journey.difficulty_level)\n    return journeyIndex <= maxIndex\n  })\n}\n\nexport function filterJourneysByDuration(\n  journeys: JourneyRoute[],\n  maxDurationMinutes: number\n): JourneyRoute[] {\n  return journeys.filter(journey => journey.estimated_duration <= maxDurationMinutes)\n}\n\n// Journey optimization\nexport function optimizeJourneyOrder(places: Place[]): Place[] {\n  if (places.length <= 2) return places\n  \n  // Simple nearest neighbor optimization\n  const optimized = [places[0]]\n  const remaining = places.slice(1)\n  \n  while (remaining.length > 0) {\n    const current = optimized[optimized.length - 1]\n    let nearestIndex = 0\n    let nearestDistance = Infinity\n    \n    remaining.forEach((place, index) => {\n      const distance = getDistanceFromLatLonInKm(\n        current.latitude, current.longitude,\n        place.latitude, place.longitude\n      )\n      \n      if (distance < nearestDistance) {\n        nearestDistance = distance\n        nearestIndex = index\n      }\n    })\n    \n    optimized.push(remaining[nearestIndex])\n    remaining.splice(nearestIndex, 1)\n  }\n  \n  return optimized\n}\n\n// Journey validation\nexport function validateJourney(journey: JourneyRoute): { valid: boolean; errors: string[] } {\n  const errors: string[] = []\n  \n  if (!journey.name || journey.name.trim().length === 0) {\n    errors.push('Journey name is required')\n  }\n  \n  if (!journey.places || journey.places.length < 2) {\n    errors.push('Journey must have at least 2 places')\n  }\n  \n  if (journey.estimated_duration <= 0) {\n    errors.push('Journey duration must be positive')\n  }\n  \n  // Check for valid coordinates\n  journey.places.forEach((connection, index) => {\n    const place = connection.place\n    if (!place.latitude || !place.longitude) {\n      errors.push(`Place ${index + 1} has invalid coordinates`)\n    }\n  })\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  }\n}